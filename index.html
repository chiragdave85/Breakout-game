<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Breakout Game</title>
  <style>
    body {
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      margin: 0;
    }
    #gameCanvas {
      background: #111;
      display: block;
      box-shadow: 0 0 32px #000a;
      border-radius: 8px;
      touch-action: none; /* prevent scroll/zoom gestures interfering with touch controls */
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="600"></canvas>
  <script>
    // Constants and simple enums
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const WIDTH = 800;
    const HEIGHT = 600;
    const BASE_BALL_SPEED = 380;
    const MAX_BALL_SPEED = 900;
  const BRICK_COLS = 10;
    const BRICK_ROWS = 6;
    const BRICK_PADDING = 8;
    const BRICK_OFFSET_LEFT = 40;
    const BRICK_OFFSET_TOP = 70;
    const BRICK_HEIGHT = 20;
    const BRICK_WIDTH = Math.floor((WIDTH - BRICK_OFFSET_LEFT * 2 - BRICK_PADDING * (BRICK_COLS - 1)) / BRICK_COLS);
  const GameState = { START: 'START', PLAYING: 'PLAYING', LEVEL_CLEARED: 'LEVEL_CLEARED', GAME_OVER: 'GAME_OVER' };
  const HEART_COLOR = '#C44536';

    // Audio module
    class AudioManager {
      constructor() { this.ctx = null; this.muted = false; }
      ensure() {
        try {
          if (!this.ctx) {
            const AC = window.AudioContext || window.webkitAudioContext;
            if (!AC) return null;
            this.ctx = new AC();
          }
          if (this.ctx.state === 'suspended') this.ctx.resume();
          return this.ctx;
        } catch { return null; }
      }
      playTone(freq, duration = 0.08, type = 'sine', volume = 0.06) {
        if (this.muted) return; const a = this.ensure(); if (!a) return;
        const osc = a.createOscillator(); const gain = a.createGain();
        osc.type = type; osc.frequency.value = freq;
        const now = a.currentTime; const attack = 0.005;
        const decay = Math.max(0.01, duration * 0.3);
        const sustain = Math.max(0.01, duration * 0.4);
        const release = Math.max(0.03, duration * 0.3);
        gain.gain.setValueAtTime(0.0001, now);
        gain.gain.linearRampToValueAtTime(volume, now + attack);
        gain.gain.exponentialRampToValueAtTime(Math.max(0.0001, volume * 0.4), now + attack + decay);
        gain.gain.setValueAtTime(Math.max(0.0001, volume * 0.4), now + attack + decay + sustain);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + attack + decay + sustain + release);
        osc.connect(gain).connect(a.destination); osc.start(now);
        osc.stop(now + attack + decay + sustain + release + 0.02);
      }
      playPaddleHit() { this.playTone(440, 0.06, 'square', 0.05); }
      playBrickHit() { this.playTone(660, 0.06, 'square', 0.05); }
      playLifeLost() { this.playTone(220, 0.25, 'sine', 0.07); }
      toggleMute() { this.muted = !this.muted; }
    }

    // Particles module
    class Particles {
      constructor(max = 450) { this.particles = []; this.MAX = max; this.enabled = true; }
      spawnBrickParticles(x, y, color) {
        if (!this.enabled) return;
        const count = this.MAX < 200 ? 6 + Math.floor(Math.random() * 4) : 14 + Math.floor(Math.random() * 8);
        for (let i = 0; i < count; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = (this.MAX < 200 ? 90 : 120) + Math.random() * (this.MAX < 200 ? 120 : 180);
          this.particles.push({ x, y, vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed, life: 0, maxLife: 0.5 + Math.random() * 0.5, size: 2 + Math.random() * 2, color });
        }
        if (this.particles.length > this.MAX) this.particles.splice(0, this.particles.length - this.MAX);
      }
      update(dt) {
        const gravity = 900;
        for (let i = this.particles.length - 1; i >= 0; i--) {
          const p = this.particles[i]; p.life += dt; if (p.life >= p.maxLife) { this.particles.splice(i, 1); continue; }
          p.vy += gravity * dt; p.vx *= 0.985; p.vy *= 0.985; p.x += p.vx * dt; p.y += p.vy * dt;
        }
      }
      draw(ctx) {
        for (const p of this.particles) {
          const t = p.life / p.maxLife; const alpha = 1 - t; ctx.save(); ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
          ctx.fillStyle = p.color; ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size); ctx.restore();
        }
      }
    }

    // High score manager
    class HighScoreManager {
      constructor(key = 'breakout_high_score') { this.key = key; this.value = 0; this.load(); }
      load() {
        try { const raw = localStorage.getItem(this.key); this.value = raw ? Math.max(0, parseInt(raw, 10) || 0) : 0; }
        catch { this.value = 0; }
      }
      save() {
        try { localStorage.setItem(this.key, String(this.value)); } catch { /* ignore */ }
      }
      setIfHigher(score) { if (score > this.value) { this.value = score; this.save(); return true; } return false; }
    }

    // Paddle entity
    class Paddle {
      constructor() { this.width = 120; this.height = 18; this.x = (WIDTH - 120) / 2; this.y = HEIGHT - 40; this.speed = 8; this.dx = 0; }
      clamp() { this.x = Math.max(0, Math.min(WIDTH - this.width, this.x)); }
      update(leftPressed, rightPressed) {
        this.dx = 0; if (leftPressed) this.dx -= this.speed; if (rightPressed) this.dx += this.speed; this.x += this.dx; this.clamp();
      }
  draw(ctx, lowGraphics) { ctx.save(); ctx.fillStyle = '#09f'; if (!lowGraphics) { ctx.shadowColor = '#00f8'; ctx.shadowBlur = 12; } ctx.fillRect(this.x, this.y, this.width, this.height); ctx.restore(); }
    }

    // Ball entity
    class Ball {
      constructor() { this.radius = 8; this.x = 0; this.y = 0; this.vx = 0; this.vy = 0; this.speed = BASE_BALL_SPEED; this.launched = false; }
      resetOnPaddle(paddle) { this.launched = false; this.vx = 0; this.vy = 0; this.x = paddle.x + paddle.width / 2; this.y = paddle.y - this.radius; }
      enforceSpeed() { const s = Math.hypot(this.vx, this.vy) || 1; this.vx = (this.vx / s) * this.speed; this.vy = (this.vy / s) * this.speed; }
      update(dt, paddle, audio, onLifeLost) {
        if (!this.launched) return; const prevY = this.y;
        this.x += this.vx * dt; this.y += this.vy * dt;
        // Walls
        if (this.x - this.radius < 0) { this.x = this.radius; this.vx = Math.abs(this.vx); }
        else if (this.x + this.radius > WIDTH) { this.x = WIDTH - this.radius; this.vx = -Math.abs(this.vx); }
        if (this.y - this.radius < 0) { this.y = this.radius; this.vy = Math.abs(this.vy); }
        // Paddle collision from above
        const r = this.radius; const ballLeft = this.x - r; const ballRight = this.x + r; const ballTop = this.y - r; const ballBottom = this.y + r;
        const prevBottom = prevY + r; const padLeft = paddle.x; const padRight = paddle.x + paddle.width; const padTop = paddle.y; const padBottom = paddle.y + paddle.height;
        const horizontalOverlap = ballRight >= padLeft && ballLeft <= padRight; const verticalOverlap = ballBottom >= padTop && ballTop <= padBottom; const crossedTopFromAbove = prevBottom <= padTop && this.vy > 0;
        if (horizontalOverlap && verticalOverlap && crossedTopFromAbove) {
          this.y = padTop - r - 0.01; const paddleCenter = paddle.x + paddle.width / 2; let t = (this.x - paddleCenter) / (paddle.width / 2); t = Math.max(-1, Math.min(1, t));
          const maxBounce = (60 * Math.PI) / 180; const angle = t * maxBounce; this.vx = this.speed * Math.sin(angle); this.vy = -this.speed * Math.cos(angle); audio.playPaddleHit();
        }
        // Bottom -> life lost
        if (this.y - this.radius > HEIGHT) { onLifeLost(); }
      }
  draw(ctx, lowGraphics) { ctx.save(); ctx.fillStyle = '#ffcc00'; if (!lowGraphics) { ctx.shadowColor = '#ffc80080'; ctx.shadowBlur = 10; } ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.restore(); }
    }

    // Brick field module
    const rowColors = ['#ff6b6b', '#feca57', '#48dbfb', '#1dd1a1', '#5f27cd', '#ee5253'];
    function circleRectCollides(cx, cy, r, rx, ry, rw, rh) {
      const closestX = Math.max(rx, Math.min(cx, rx + rw)); const closestY = Math.max(ry, Math.min(cy, ry + rh));
      const dx = cx - closestX; const dy = cy - closestY; return dx * dx + dy * dy <= r * r;
    }
    class BrickField {
      constructor(level = 1) { this.bricks = []; this.init(level); }
      getLevelColors(lv) { const rot = (lv - 1) % rowColors.length; const out = []; for (let i = 0; i < rowColors.length; i++) out.push(rowColors[(i + rot) % rowColors.length]); return out; }
      isBrickAliveForLevel(lv, r, c) {
        const pattern = (lv - 1) % 6; switch (pattern) {
          case 0: return true; case 1: return ((r + c) % 2) === 0; case 2: return (r % 2) === 0; case 3: return (c % 2) === 0;
          case 4: return (r === 0 || r === BRICK_ROWS - 1 || c === 0 || c === BRICK_COLS - 1);
          case 5: { let width = BRICK_COLS - r * 2; if (width <= 0) width = 1; const start = Math.floor((BRICK_COLS - width) / 2); return c >= start && c < start + width; }
          default: return true; }
      }
      init(level) {
        this.level = level; this.bricks = []; const colors = this.getLevelColors(level);
        for (let r = 0; r < BRICK_ROWS; r++) { const row = []; for (let c = 0; c < BRICK_COLS; c++) {
            const x = BRICK_OFFSET_LEFT + c * (BRICK_WIDTH + BRICK_PADDING); const y = BRICK_OFFSET_TOP + r * (BRICK_HEIGHT + BRICK_PADDING);
            const alive = this.isBrickAliveForLevel(level, r, c); row.push({ x, y, w: BRICK_WIDTH, h: BRICK_HEIGHT, alive, color: colors[r % colors.length] }); }
          this.bricks.push(row); }
      }
      draw(ctx, lowGraphics = false) {
        for (let r = 0; r < BRICK_ROWS; r++) {
          for (let c = 0; c < BRICK_COLS; c++) {
            const b = this.bricks[r][c]; if (!b.alive) continue;
            ctx.save(); ctx.fillStyle = b.color;
            if (!lowGraphics) { ctx.shadowColor = b.color + '80'; ctx.shadowBlur = 8; }
            ctx.fillRect(b.x, b.y, b.w, b.h); ctx.restore();
          }
        }
      }
      allCleared() { for (let r = 0; r < BRICK_ROWS; r++) for (let c = 0; c < BRICK_COLS; c++) if (this.bricks[r][c].alive) return false; return true; }
      handleCollisions(ball) {
        for (let r = 0; r < BRICK_ROWS; r++) {
          for (let c = 0; c < BRICK_COLS; c++) {
            const b = this.bricks[r][c]; if (!b.alive) continue;
            if (circleRectCollides(ball.x, ball.y, ball.radius, b.x, b.y, b.w, b.h)) {
              const vyBefore = ball.vy; if (vyBefore > 0) ball.y = b.y - ball.radius - 0.01; else ball.y = b.y + b.h + ball.radius + 0.01;
              ball.vy = -ball.vy; ball.enforceSpeed(); b.alive = false;
              return { hit: true, cx: b.x + b.w / 2, cy: b.y + b.h / 2, color: b.color, scoreDelta: 100 };
            }
          }
        }
        return { hit: false };
      }
    }

    // Renderer module (HUD, overlays, FPS, screen shake and world grouping)
    class Renderer {
      constructor(ctx) {
        this.ctx = ctx;
        this.shake = { time: 0, duration: 0, magnitude: 0 };
        this.fps = 0;
  this.lowGraphics = false;
        // Heart pop animation state
        this.heartPop = { slot: -1, time: 0, duration: 0.35 };
        this._lastHudUpdate = performance.now();
  // Lives icons
  this.icons = { empty: new Image(), filled: new Image(), ready: false, _loaded: 0 };
        this.icons.empty.onload = () => { this.icons._loaded++; if (this.icons._loaded >= 2) this.icons.ready = true; };
        this.icons.filled.onload = () => { this.icons._loaded++; if (this.icons._loaded >= 2) this.icons.ready = true; };
        this.icons.empty.onerror = (e) => { console.error('Failed to load heart-empty.png', e); };
        this.icons.filled.onerror = (e) => { console.error('Failed to load heart-filled.png', e); };
        try {
          this.icons.filled.src = new URL('heart-filled.png', window.location.href).toString(); // full/remaining life
          this.icons.empty.src = new URL('heart-empty.png', window.location.href).toString();   // lost life
        } catch(_) {
          // Fallback to relative if URL construction fails
          this.icons.filled.src = 'heart-filled.png';
          this.icons.empty.src = 'heart-empty.png';
        }
      }
      triggerShake(mag = 3, durationMs = 120) { this.shake.magnitude = mag; this.shake.duration = durationMs / 1000; this.shake.time = this.shake.duration; }
      triggerHeartPop(slot, durationMs = 350) { this.heartPop.slot = slot; this.heartPop.duration = durationMs / 1000; this.heartPop.time = this.heartPop.duration; }
      beginWorld(now, lastTick) {
        const ctx = this.ctx; ctx.save();
        if (this.shake.time > 0) { const k = this.shake.time / this.shake.duration; const mag = this.shake.magnitude * k; const ox = (Math.random() * 2 - 1) * mag; const oy = (Math.random() * 2 - 1) * mag; ctx.translate(ox, oy);
          this.shake.time -= Math.min(0.033, (now - lastTick) / 1000); if (this.shake.time < 0) this.shake.time = 0; }
      }
      endWorld() { this.ctx.restore(); }
      drawBackground() { const ctx = this.ctx; ctx.fillStyle = '#111'; ctx.fillRect(0, 0, WIDTH, HEIGHT); }
      drawHUD(score, lives, level, highScore, highFlashAlpha = 0, gameState = GameState.PLAYING, dt = 0) {
        // Update HUD-local animations (use dt from main loop if provided)
        if (!dt || !isFinite(dt) || dt <= 0) {
          const now = performance.now();
          dt = Math.max(0.001, (now - this._lastHudUpdate) / 1000);
          this._lastHudUpdate = now;
        }
        if (this.heartPop.time > 0) this.heartPop.time = Math.max(0, this.heartPop.time - dt);

        const ctx = this.ctx; ctx.save(); ctx.textBaseline = 'top';
        // Optional small title during gameplay states (not on START)
        if (gameState !== GameState.START) {
          ctx.textAlign = 'center'; ctx.font = '16px monospace';
          ctx.save();
          if (!this.lowGraphics) { ctx.shadowColor = '#ffffff88'; ctx.shadowBlur = 8; }
          ctx.fillStyle = '#fff';
          ctx.fillText('Breakout', WIDTH / 2, 6);
          ctx.restore();
        }
        // Left block: Score and High Score stacked
        ctx.textAlign = 'left';
        ctx.font = '20px monospace'; ctx.fillStyle = '#fff'; ctx.fillText(`Score: ${score}`, 10, 10);
        ctx.font = '14px monospace';
        if (highFlashAlpha > 0) {
          // Flash between gold and white
          const a = Math.max(0, Math.min(1, highFlashAlpha));
          const blink = a; // already shaped externally
          ctx.fillStyle = blink > 0.5 ? '#ffd700' : '#fff';
        } else {
          ctx.fillStyle = '#ddd';
        }
        ctx.fillText(`High: ${highScore}`, 10, 34);
        // Center: Lives shown as filled hearts (slightly lower to make room for title)
        const totalSlots = 3;
        const clampedLives = Math.max(0, Math.min(totalSlots, lives|0));
        const size = 14; // heart bounding size in px
        const spacing = 8;
        const totalW = totalSlots * size + (totalSlots - 1) * spacing;
        let startX = Math.round(WIDTH / 2 - totalW / 2);
        const y = 26;
        for (let i = 0; i < totalSlots; i++) {
          const isFilled = i < clampedLives; // remaining lives (full)
          // Base icon (now: filled.png for full life, empty.png for lost)
          if (this.icons.ready) {
            const img = isFilled ? this.icons.filled : this.icons.empty;
            this.drawHeartImage(startX, y, size, img);
          } else {
            // Fallback to vector hearts while icons load
            if (isFilled) this.drawHeart(startX, y, size, HEART_COLOR);
            else this.drawHeartOutline(startX, y, size, HEART_COLOR);
          }
          // Pop animation overlay for the just-lost heart slot
          if (i === this.heartPop.slot && this.heartPop.time > 0) {
            const k = 1 - (this.heartPop.time / this.heartPop.duration); // 0 -> 1
            const ease = 1 - Math.pow(1 - k, 3); // easeOutCubic
            const scale = 1 + 0.4 * ease;
            const alpha = 1 - ease;
            const yOffset = -6 * ease;
            if (this.icons.ready) {
              // Overlay uses the icon that just changed (lost life => now shows empty)
              const img = this.icons.empty;
              this.drawHeartImage(startX, y + yOffset, size, img, { scale, alpha });
            } else {
              this.drawHeart(startX, y + yOffset, size, HEART_COLOR, { scale, alpha });
            }
          }
          startX += size + spacing;
        }
        // Right: Level
        ctx.textAlign = 'right'; ctx.fillText(`Level: ${level}`, WIDTH - 10, 10);
        ctx.restore();
      }

      // Build a clean, symmetric heart path inside the box at (x,y) with size x size.
      buildHeartPath(ctx, x, y, size) {
        const w = size, h = size;
        // Control: top lobes centers and radius for smooth arcs
        const r = w * 0.26;
        const cxL = x + w * 0.35, cyL = y + h * 0.35;
        const cxR = x + w * 0.65, cyR = y + h * 0.35;
        const tipX = x + w * 0.5, tipY = y + h * 0.98;
        ctx.beginPath();
        // Start at bottom tip
        ctx.moveTo(tipX, tipY);
        // Left edge up to left arc start
        ctx.bezierCurveTo(x + w * 0.12, y + h * 0.82, x + w * 0.02, y + h * 0.55, x + w * 0.22, y + h * 0.38);
        // Left lobe
        ctx.arc(cxL, cyL, r, Math.PI * 0.9, Math.PI * 2.1, false);
        // Right lobe
        ctx.arc(cxR, cyR, r, Math.PI, 0, false);
        // Right edge back to tip
        ctx.bezierCurveTo(x + w * 0.98, y + h * 0.55, x + w * 0.88, y + h * 0.82, tipX, tipY);
        ctx.closePath();
      }
      // Draw a filled heart with top-left at (x, y), roughly size x size box
      drawHeart(x, y, size, color = HEART_COLOR, opts = undefined) {
        const ctx = this.ctx;
        ctx.save();
        const scale = opts?.scale || 1;
        const alpha = opts?.alpha ?? 1;
        // Scale around heart center so pop animation stays centered
        const cx = x + size / 2, cy = y + size / 2;
        ctx.translate(cx, cy);
        ctx.scale(scale, scale);
        ctx.translate(-cx, -cy);
        ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
        ctx.fillStyle = color;
        this.buildHeartPath(ctx, x, y, size);
        ctx.fill();
        ctx.restore();
      }
      drawHeartOutline(x, y, size, color = HEART_COLOR) {
        const ctx = this.ctx;
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = Math.max(1, Math.round(size * 0.12));
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        this.buildHeartPath(ctx, x, y, size);
        ctx.stroke();
        ctx.restore();
      }
  drawFPS() { const ctx = this.ctx; ctx.save(); ctx.font = '16px monospace'; ctx.fillStyle = '#0f0'; ctx.textBaseline = 'bottom'; ctx.textAlign = 'left'; ctx.fillText(`FPS: ${this.fps}${this.lowGraphics ? ' (Low)' : ''}`, 10, HEIGHT - 10); ctx.restore(); }

      // Draw a heart icon image, with optional scale/alpha animated around center
      drawHeartImage(x, y, size, img, opts = undefined) {
        const ctx = this.ctx;
        const scale = opts?.scale || 1;
        const alpha = opts?.alpha ?? 1;
        ctx.save();
        const cx = x + size / 2, cy = y + size / 2;
        ctx.translate(cx, cy);
        ctx.scale(scale, scale);
        ctx.translate(-cx, -cy);
        ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
        // Preserve aspect ratio of the image; letterbox inside size x size
        const iw = img.naturalWidth || img.width || size;
        const ih = img.naturalHeight || img.height || size;
        let dw = size, dh = size;
        if (iw && ih) {
          const ir = iw / ih; const sr = 1; // target square
          if (ir > sr) { dh = size / ir; dw = size; } else { dw = size * ir; dh = size; }
        }
        const dx = Math.round(cx - dw / 2);
        const dy = Math.round(cy - dh / 2);
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = this.lowGraphics ? 'low' : 'high';
        ctx.drawImage(img, dx, dy, dw, dh);
        ctx.restore();
      }
      drawOverlay(gameState, paused) {
        const ctx = this.ctx; ctx.save(); ctx.fillStyle = '#fff'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; const cx = WIDTH / 2; const cy = HEIGHT / 2;
        if (gameState === GameState.START) {
          ctx.save();
          ctx.shadowColor = '#ffffffaa';
          ctx.shadowBlur = 24;
          ctx.font = '48px monospace'; ctx.fillStyle = '#fff';
          ctx.fillText('Breakout', cx, cy - 40);
          ctx.restore();
          // Pulsing subtitle
          ctx.save();
          const t = performance.now();
          const pulse = 0.5 + 0.5 * Math.sin(t / 400); // ~2.5s cycle
          ctx.globalAlpha = 0.6 + 0.4 * pulse; // 0.6..1.0 alpha
          ctx.font = '28px monospace';
          ctx.fillStyle = '#fff';
          ctx.shadowColor = '#ffffff55';
          ctx.shadowBlur = 10;
          ctx.fillText('Press Space to Start', cx, cy);
          ctx.restore();
          ctx.font = '16px monospace'; ctx.fillText('Controls: Arrow keys or Mouse/Touch | P: Pause | M: Mute | Shift+M: Reset High', cx, cy + 30);
        }
        else if (gameState === GameState.LEVEL_CLEARED) {
          // Pulsing title
          ctx.save();
          const t = performance.now();
          const pulse = 0.5 + 0.5 * Math.sin(t / 400);
          ctx.globalAlpha = 0.6 + 0.4 * pulse;
          ctx.font = '32px monospace';
          ctx.fillText('Level Cleared!', cx, cy - 20);
          ctx.restore();
          ctx.font = '24px monospace';
          ctx.fillText('Press Space for Next Level', cx, cy + 20);
        }
        else if (gameState === GameState.GAME_OVER) {
          ctx.save();
          const t = performance.now();
          const pulse = 0.5 + 0.5 * Math.sin(t / 400);
          ctx.globalAlpha = 0.6 + 0.4 * pulse;
          ctx.font = '32px monospace';
          ctx.fillText('Game Over!', cx, cy - 20);
          ctx.restore();
          ctx.font = '24px monospace';
          ctx.fillText('Press Space to Restart', cx, cy + 20);
        }
        if (paused && gameState === GameState.PLAYING) { ctx.font = '32px monospace'; ctx.fillText('Paused', cx, cy + 60); }
        ctx.restore();
      }
    }

    // Input module
    class Input {
      constructor(canvas, { isPaused, toGameX, onPrimaryAction, onTapAction, onTogglePause, onToggleMute, onResetHighScore, onPaddleMove, onPointerInteract }) {
        this.leftPressed = false; this.rightPressed = false; this.isPaused = isPaused; this.toGameX = toGameX;
        this.onPrimaryAction = onPrimaryAction; this.onTapAction = onTapAction; this.onTogglePause = onTogglePause; this.onToggleMute = onToggleMute; this.onResetHighScore = onResetHighScore; this.onPaddleMove = onPaddleMove; this.onPointerInteract = onPointerInteract;
        this.TAP_MOVE_THRESHOLD = 10; this.touchStartX = 0; this.touchMoved = false; this.attach(canvas);
      }
      attach(canvas) {
        document.addEventListener('keydown', (e) => {
          this.onPointerInteract();
          if (e.code === 'ArrowLeft') this.leftPressed = true;
          if (e.code === 'ArrowRight') this.rightPressed = true;
          if (e.code === 'KeyM' && e.shiftKey) { this.onResetHighScore(); }
          else if (e.code === 'KeyM') { this.onToggleMute(); }
          if (e.code === 'KeyP') this.onTogglePause();
          if (e.code === 'Space') { e.preventDefault(); this.onPrimaryAction(); }
          if (e.code === 'KeyL') { const g = window.__gameInstance; if (g) { g.renderer.lowGraphics = !g.renderer.lowGraphics; g.particles.MAX = g.renderer.lowGraphics ? 150 : 450; g.particles.enabled = true; } }
        });
        document.addEventListener('keyup', (e) => {
          if (e.code === 'ArrowLeft') this.leftPressed = false;
          if (e.code === 'ArrowRight') this.rightPressed = false;
        });
        canvas.addEventListener('mousemove', (e) => {
          const x = this.toGameX(e.clientX); if (!this.isPaused()) this.onPaddleMove(x);
        });
        canvas.addEventListener('touchstart', (e) => {
          this.onPointerInteract(); if (e.cancelable) e.preventDefault(); if (this.isPaused()) return; const t = e.touches[0]; this.touchStartX = this.toGameX(t.clientX); this.touchMoved = false; this.onPaddleMove(this.touchStartX);
        }, { passive: false });
        canvas.addEventListener('touchmove', (e) => {
          if (e.cancelable) e.preventDefault(); if (this.isPaused()) return; const t = e.touches[0]; const x = this.toGameX(t.clientX); if (Math.abs(x - this.touchStartX) > this.TAP_MOVE_THRESHOLD) this.touchMoved = true; this.onPaddleMove(x);
        }, { passive: false });
        canvas.addEventListener('touchend', (e) => {
          if (e.cancelable) e.preventDefault(); if (this.isPaused()) return; if (!this.touchMoved) this.onTapAction();
        }, { passive: false });
        canvas.addEventListener('pointerdown', () => this.onPointerInteract());
      }
    }

    // Game orchestrator
    class Game {
      constructor(canvas) {
        this.canvas = canvas; this.ctx = ctx; this.currentScale = 1; this.frames = 0; this.lastFpsUpdate = performance.now(); this.lastTick = performance.now();
        this.state = GameState.START; this.score = 0; this.lives = 3; this.level = 1; this.paused = false; this.autoPaused = false;
        this.audio = new AudioManager(); this.renderer = new Renderer(this.ctx); this.particles = new Particles();
        this.highScores = new HighScoreManager(); this.highScoreFlash = 0; // seconds remaining for flash
        this.paddle = new Paddle(); this.ball = new Ball(); this.bricks = new BrickField(this.level);
        this.resizeCanvas = this.resizeCanvas.bind(this); this.onVisibility = this.onVisibility.bind(this);
        window.addEventListener('resize', this.resizeCanvas); document.addEventListener('visibilitychange', this.onVisibility); this.resizeCanvas();
        // Input
        this.input = new Input(canvas, {
          isPaused: () => this.isPaused(),
          toGameX: (clientX) => this.toGameX(clientX),
          onPrimaryAction: () => this.onPrimaryAction(),
          onTapAction: () => this.onTapAction(),
          onTogglePause: () => { if (this.state === GameState.PLAYING) this.paused = !this.paused; },
          onToggleMute: () => this.audio.toggleMute(),
          onResetHighScore: () => this.onResetHighScore(),
          onPaddleMove: (x) => this.onPaddleMove(x),
          onPointerInteract: () => this.audio.ensure(),
        });
        this.ball.resetOnPaddle(this.paddle);
  requestAnimationFrame((t) => this.loop(t));
      }
      // Scaling
      resizeCanvas() {
        const dpr = window.devicePixelRatio || 1;
  const scaleX = window.innerWidth / WIDTH; const scaleY = window.innerHeight / HEIGHT;
  const target = Math.max(0.1, Math.min(scaleX, scaleY));
  // Cap CSS scale to limit composite cost on large viewports
  this.currentScale = Math.min(1.25, target);
        const cssW = Math.floor(WIDTH * this.currentScale); const cssH = Math.floor(HEIGHT * this.currentScale);
        // CSS controls visual size; backing store is only DPR-scaled to keep draw cost low
        this.canvas.style.width = cssW + 'px';
        this.canvas.style.height = cssH + 'px';
        this.canvas.width = Math.floor(WIDTH * dpr);
        this.canvas.height = Math.floor(HEIGHT * dpr);
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.scale(dpr, dpr);
      }
      toGameX(clientX) {
        const rect = this.canvas.getBoundingClientRect();
        const xCss = clientX - rect.left;
        // currentScale already reflects CSS scale; logical = css / currentScale
        return xCss / this.currentScale;
      }
      // Pause control
      isPaused() { return this.paused || this.autoPaused; }
      onVisibility() { this.autoPaused = document.hidden; }
      // Input-driven actions
      onPaddleMove(x) {
        if (this.isPaused()) return; this.paddle.x = x - this.paddle.width / 2; this.paddle.clamp(); if (!this.ball.launched) { this.ball.x = this.paddle.x + this.paddle.width / 2; this.ball.y = this.paddle.y - this.ball.radius; }
      }
      onPrimaryAction() {
        if (this.state === GameState.START) { this.state = GameState.PLAYING; if (!this.ball.launched) { const angle = -Math.PI / 4; this.ball.vx = Math.cos(angle) * this.ball.speed; this.ball.vy = Math.sin(angle) * this.ball.speed; this.ball.launched = true; } }
        else if (this.state === GameState.PLAYING) { if (!this.ball.launched) { const angle = -Math.PI / 4; this.ball.vx = Math.cos(angle) * this.ball.speed; this.ball.vy = Math.sin(angle) * this.ball.speed; this.ball.launched = true; } }
        else if (this.state === GameState.LEVEL_CLEARED) { this.level += 1; this.ball.speed = Math.min(MAX_BALL_SPEED, Math.round(this.ball.speed * 1.1)); this.bricks.init(this.level); this.ball.resetOnPaddle(this.paddle); this.state = GameState.PLAYING; }
        else if (this.state === GameState.GAME_OVER) { this.score = 0; this.lives = 3; this.level = 1; this.ball.speed = BASE_BALL_SPEED; this.bricks.init(this.level); this.ball.resetOnPaddle(this.paddle); this.state = GameState.START; }
      }
      onTapAction() {
        if (this.state === GameState.START) { this.state = GameState.PLAYING; if (!this.ball.launched) { const angle = -Math.PI / 4; this.ball.vx = Math.cos(angle) * this.ball.speed; this.ball.vy = Math.sin(angle) * this.ball.speed; this.ball.launched = true; } }
        else if (this.state === GameState.LEVEL_CLEARED) { this.level += 1; this.ball.speed = Math.min(MAX_BALL_SPEED, Math.round(this.ball.speed * 1.1)); this.bricks.init(this.level); this.ball.resetOnPaddle(this.paddle); this.state = GameState.PLAYING; }
        // In PLAYING, a tap does not launch; matches previous touch behavior.
      }
      onResetHighScore() {
        if (confirm('Reset high score?')) { this.highScores.value = 0; this.highScores.save(); this.highScoreFlash = 0; }
      }
      // Update systems
      update(dt) {
        if (!this.isPaused()) {
          this.paddle.update(this.input.leftPressed, this.input.rightPressed);
          if (!this.ball.launched) { this.ball.x = this.paddle.x + this.paddle.width / 2; this.ball.y = this.paddle.y - this.ball.radius; }
        }
        if (!this.isPaused() && this.state === GameState.PLAYING) {
          this.ball.update(dt, this.paddle, this.audio, () => this.onLifeLost());
          const hit = this.bricks.handleCollisions(this.ball);
          if (hit.hit) {
            this.audio.playBrickHit();
            this.score += hit.scoreDelta * Math.max(1, this.level);
            if (this.highScores.setIfHigher(this.score)) {
              // Trigger a brief flash effect for new high score
              this.highScoreFlash = 2.5; // seconds
            }
            this.particles.spawnBrickParticles(hit.cx, hit.cy, hit.color);
          }
          if (this.bricks.allCleared()) { this.ball.resetOnPaddle(this.paddle); this.state = GameState.LEVEL_CLEARED; }
        }
        if (!this.isPaused()) {
          this.particles.update(dt);
          if (this.highScoreFlash > 0) this.highScoreFlash = Math.max(0, this.highScoreFlash - dt);
        }
      }
      onLifeLost() {
  // Determine which heart slot changes from filled to outline (0-based left to right)
  const slot = Math.max(0, Math.min(2, this.lives - 1));
  this.lives -= 1;
  this.renderer.triggerHeartPop(slot);
  this.audio.playLifeLost();
  if (this.lives <= 0) { this.ball.resetOnPaddle(this.paddle); this.state = GameState.GAME_OVER; }
  else { this.ball.resetOnPaddle(this.paddle); }
      }
      // Draw
    draw(now, dt) {
        this.renderer.drawBackground();
        this.renderer.beginWorld(now, this.lastTick);
  this.bricks.draw(this.ctx, this.renderer.lowGraphics);
  this.particles.draw(this.ctx);
  this.paddle.draw(this.ctx, this.renderer.lowGraphics);
  this.ball.draw(this.ctx, this.renderer.lowGraphics);
        this.renderer.endWorld();
        // Compute a flashing alpha [0..1] for the high score effect
        const flashAlpha = this.highScoreFlash > 0 ? 0.5 + 0.5 * Math.sin((2 * Math.PI) * (performance.now() / 200)) : 0;
  this.renderer.drawHUD(this.score, this.lives, this.level, this.highScores.value, flashAlpha, this.state, dt);
        this.renderer.drawFPS();
        this.renderer.drawOverlay(this.state, this.isPaused());
      }
      // Loop
      loop(now) {
        // FPS calc
        this.frames++; if (now - this.lastFpsUpdate > 1000) {
          this.renderer.fps = Math.round((this.frames * 1000) / (now - this.lastFpsUpdate));
          // Auto low-graphics if sustained low FPS
          if (this.renderer.fps < 45) { this.renderer.lowGraphics = true; this.particles.MAX = 150; this.particles.enabled = true; }
          this.frames = 0; this.lastFpsUpdate = now;
        }
  const dt = Math.min(0.05, Math.max(0.001, (now - this.lastTick) / 1000)); this.lastTick = now;
        this.ctx.clearRect(0, 0, WIDTH, HEIGHT);
  this.update(dt); this.draw(now, dt);
        requestAnimationFrame((t) => this.loop(t));
      }
    }

    // Boot
  window.__gameInstance = new Game(canvas);
  </script>
</body>
</html>
